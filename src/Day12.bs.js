// Generated by BUCKLESCRIPT VERSION 5.0.4, PLEASE EDIT WITH CARE
'use strict';

var Fs = require("fs");
var Path = require("path");
var $$Array = require("bs-platform/lib/js/array.js");
var Js_option = require("bs-platform/lib/js/js_option.js");
var Caml_array = require("bs-platform/lib/js/caml_array.js");
var Caml_int32 = require("bs-platform/lib/js/caml_int32.js");
var Pervasives = require("bs-platform/lib/js/pervasives.js");
var Caml_format = require("bs-platform/lib/js/caml_format.js");
var Caml_option = require("bs-platform/lib/js/caml_option.js");
var Caml_primitive = require("bs-platform/lib/js/caml_primitive.js");
var Caml_js_exceptions = require("bs-platform/lib/js/caml_js_exceptions.js");

var inputPath = "./src/" + (Path.parse("Day12.re").name + ".input");

var input = Fs.readFileSync(inputPath, "utf8").split("\n");

function parseMoon(str) {
  var re = (/^<x=(.+), y=(.+), z=(.+)>$/);
  var exit = 0;
  var val;
  try {
    val = $$Array.map(Caml_format.caml_int_of_string, $$Array.map((function (prim) {
                return prim.trim();
              }), Js_option.getExn(Caml_option.null_to_opt(str.match(re))).slice(1)));
    exit = 1;
  }
  catch (raw_e){
    var e = Caml_js_exceptions.internalToOCamlException(raw_e);
    console.log("exception was raised while parsing input: " + str, e);
    throw e;
  }
  if (exit === 1) {
    if (val.length !== 3) {
      return Pervasives.failwith("failed to parse input: " + str);
    } else {
      var x = val[0];
      var y = val[1];
      var z = val[2];
      return /* tuple */[
              /* record */[
                /* x */x,
                /* y */y,
                /* z */z
              ],
              /* record */[
                /* vx */0,
                /* vy */0,
                /* vz */0
              ]
            ];
    }
  }
  
}

function sign(n) {
  var match = n > 0;
  if (match) {
    return 1;
  } else {
    var match$1 = n < 0;
    if (match$1) {
      return -1;
    } else {
      return 0;
    }
  }
}

function applyGravity(moon1, moon2) {
  var match = moon2[1];
  var p2 = moon2[0];
  var match$1 = moon1[1];
  var p1 = moon1[0];
  var dvx1 = sign(Caml_primitive.caml_int_compare(p2[/* x */0], p1[/* x */0]));
  var dvy1 = sign(Caml_primitive.caml_int_compare(p2[/* y */1], p1[/* y */1]));
  var dvz1 = sign(Caml_primitive.caml_int_compare(p2[/* z */2], p1[/* z */2]));
  var dvx2 = Caml_int32.imul(-1, dvx1);
  var dvy2 = Caml_int32.imul(-1, dvy1);
  var dvz2 = Caml_int32.imul(-1, dvz1);
  var newMoon1_001 = /* record */[
    /* vx */match$1[/* vx */0] + dvx1 | 0,
    /* vy */match$1[/* vy */1] + dvy1 | 0,
    /* vz */match$1[/* vz */2] + dvz1 | 0
  ];
  var newMoon1 = /* tuple */[
    p1,
    newMoon1_001
  ];
  var newMoon2_001 = /* record */[
    /* vx */match[/* vx */0] + dvx2 | 0,
    /* vy */match[/* vy */1] + dvy2 | 0,
    /* vz */match[/* vz */2] + dvz2 | 0
  ];
  var newMoon2 = /* tuple */[
    p2,
    newMoon2_001
  ];
  return /* tuple */[
          newMoon1,
          newMoon2
        ];
}

function applyVelocity(param) {
  var v = param[1];
  var match = param[0];
  return /* tuple */[
          /* record */[
            /* x */match[/* x */0] + v[/* vx */0] | 0,
            /* y */match[/* y */1] + v[/* vy */1] | 0,
            /* z */match[/* z */2] + v[/* vz */2] | 0
          ],
          v
        ];
}

function totalEnergy(param) {
  var match = param[1];
  var match$1 = param[0];
  var energy = function (coords) {
    return $$Array.fold_left((function (prim, prim$1) {
                  return prim + prim$1 | 0;
                }), 0, $$Array.map(Pervasives.abs, coords));
  };
  return Caml_int32.imul(energy(/* array */[
                  match$1[/* x */0],
                  match$1[/* y */1],
                  match$1[/* z */2]
                ]), energy(/* array */[
                  match[/* vx */0],
                  match[/* vy */1],
                  match[/* vz */2]
                ]));
}

function tick(moons, n) {
  var _moons = $$Array.copy(moons);
  var _n = n;
  while(true) {
    var n$1 = _n;
    var moons$1 = _moons;
    if (n$1 === 0) {
      return moons$1;
    } else {
      for(var i = 0 ,i_finish = moons$1.length - 1 | 0; i <= i_finish; ++i){
        for(var j = i + 1 | 0 ,j_finish = moons$1.length - 1 | 0; j <= j_finish; ++j){
          var match = applyGravity(Caml_array.caml_array_get(moons$1, i), Caml_array.caml_array_get(moons$1, j));
          Caml_array.caml_array_set(moons$1, i, match[0]);
          Caml_array.caml_array_set(moons$1, j, match[1]);
        }
      }
      var nextMoons = $$Array.map(applyVelocity, moons$1);
      _n = n$1 - 1 | 0;
      _moons = nextMoons;
      continue ;
    }
  };
}

var moons = $$Array.map(parseMoon, input);

var result = $$Array.fold_left((function (prim, prim$1) {
        return prim + prim$1 | 0;
      }), 0, $$Array.map(totalEnergy, tick(moons, 1000)));

console.log("Part1 output: ", result);

var Part1 = /* module */[
  /* tick */tick,
  /* moons */moons,
  /* result */result
];

var result$1 = "TBD";

console.log("Part2 output: ", result$1);

var Part2 = /* module */[/* result */result$1];

exports.inputPath = inputPath;
exports.input = input;
exports.parseMoon = parseMoon;
exports.sign = sign;
exports.applyGravity = applyGravity;
exports.applyVelocity = applyVelocity;
exports.totalEnergy = totalEnergy;
exports.Part1 = Part1;
exports.Part2 = Part2;
/* inputPath Not a pure module */
