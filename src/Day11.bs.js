// Generated by BUCKLESCRIPT VERSION 5.0.4, PLEASE EDIT WITH CARE
'use strict';

var Fs = require("fs");
var Path = require("path");
var $$Array = require("bs-platform/lib/js/array.js");
var Belt_Id = require("bs-platform/lib/js/belt_Id.js");
var Belt_Map = require("bs-platform/lib/js/belt_Map.js");
var Caml_obj = require("bs-platform/lib/js/caml_obj.js");
var Caml_array = require("bs-platform/lib/js/caml_array.js");
var Pervasives = require("bs-platform/lib/js/pervasives.js");
var Caml_format = require("bs-platform/lib/js/caml_format.js");
var Caml_primitive = require("bs-platform/lib/js/caml_primitive.js");
var IntCodeComputer$Adventofcode2019 = require("./IntCodeComputer.bs.js");

var inputPath = "./src/" + (Path.parse("Day11.re").name + ".input");

var input = Fs.readFileSync(inputPath, "utf8");

var cmp = Caml_obj.caml_compare;

var Coords = Belt_Id.MakeComparable(/* module */[/* cmp */cmp]);

function make(color) {
  return /* record */[
          /* hull */Belt_Map.fromArray(/* array */[/* tuple */[
                  /* tuple */[
                    0,
                    0
                  ],
                  color
                ]], Coords),
          /* robot : tuple */[
            /* tuple */[
              0,
              0
            ],
            /* Up */0
          ]
        ];
}

function detectColor(param) {
  var coords = param[/* robot */1][0];
  return Belt_Map.getWithDefault(param[/* hull */0], coords, /* Black */0);
}

function moveRobot(robot, rotate) {
  var direction = robot[1];
  var match = robot[0];
  var y = match[1];
  var x = match[0];
  var newDirection;
  if (rotate) {
    switch (direction) {
      case 0 : 
          newDirection = /* Right */1;
          break;
      case 1 : 
          newDirection = /* Down */2;
          break;
      case 2 : 
          newDirection = /* Left */3;
          break;
      case 3 : 
          newDirection = /* Up */0;
          break;
      
    }
  } else {
    switch (direction) {
      case 0 : 
          newDirection = /* Left */3;
          break;
      case 1 : 
          newDirection = /* Up */0;
          break;
      case 2 : 
          newDirection = /* Right */1;
          break;
      case 3 : 
          newDirection = /* Down */2;
          break;
      
    }
  }
  var newCoords;
  switch (newDirection) {
    case 0 : 
        newCoords = /* tuple */[
          x,
          y + 1 | 0
        ];
        break;
    case 1 : 
        newCoords = /* tuple */[
          x + 1 | 0,
          y
        ];
        break;
    case 2 : 
        newCoords = /* tuple */[
          x,
          y - 1 | 0
        ];
        break;
    case 3 : 
        newCoords = /* tuple */[
          x - 1 | 0,
          y
        ];
        break;
    
  }
  return /* tuple */[
          newCoords,
          newDirection
        ];
}

function paintAndMove(param, color, rotate) {
  var robot = param[/* robot */1];
  var coords = robot[0];
  var hull = Belt_Map.set(param[/* hull */0], coords, color);
  var robot$1 = moveRobot(robot, rotate);
  return /* record */[
          /* hull */hull,
          /* robot */robot$1
        ];
}

function countPaintedPanels(param) {
  return Belt_Map.size(param[/* hull */0]);
}

function printHull(param) {
  var hull = param[/* hull */0];
  var coords = Belt_Map.keysToArray(hull);
  var match = $$Array.fold_left((function (param, param$1) {
          var y = param$1[1];
          var x = param$1[0];
          return /* tuple */[
                  Caml_primitive.caml_int_min(param[0], x),
                  Caml_primitive.caml_int_max(param[1], x),
                  Caml_primitive.caml_int_min(param[2], y),
                  Caml_primitive.caml_int_max(param[3], y)
                ];
        }), /* tuple */[
        Pervasives.max_int,
        Pervasives.min_int,
        Pervasives.max_int,
        Pervasives.min_int
      ], coords);
  var minY = match[2];
  var minX = match[0];
  var grid = $$Array.make_matrix((match[1] - minX | 0) + 1 | 0, (match[3] - minY | 0) + 1 | 0, ".");
  $$Array.iter((function (coord) {
          var color = Belt_Map.getExn(hull, coord);
          return Caml_array.caml_array_set(Caml_array.caml_array_get(grid, coord[0] - minX | 0), coord[1] - minY | 0, color ? "#" : ".");
        }), coords);
  return $$Array.iter((function (row) {
                console.log(row.join(""));
                return /* () */0;
              }), grid);
}

var HullPaintingRobot = /* module */[
  /* make */make,
  /* detectColor */detectColor,
  /* paintAndMove */paintAndMove,
  /* countPaintedPanels */countPaintedPanels,
  /* printHull */printHull
];

var program = $$Array.map(Caml_format.caml_float_of_string, input.split(","));

var $$break = /* record */[/* contents */false];

var computer = /* record */[/* contents */IntCodeComputer$Adventofcode2019.make(undefined, program)];

var robot = /* record */[/* contents */make(/* Black */0)];

while(!$$break[0]) {
  var match = detectColor(robot[0]);
  var color = match ? 1 : 0;
  var match$1 = IntCodeComputer$Adventofcode2019.run(computer[0], /* array */[color]);
  var exitCode1 = match$1[1];
  if (typeof exitCode1 === "number") {
    if (exitCode1 !== 0) {
      Pervasives.failwith("program should not request input here!");
    } else {
      $$break[0] = true;
    }
  } else {
    var match$2 = exitCode1[0] === 0;
    var newColor = match$2 ? /* Black */0 : /* White */1;
    var match$3 = IntCodeComputer$Adventofcode2019.run(match$1[0], /* array */[]);
    var exitCode2 = match$3[1];
    computer[0] = match$3[0];
    if (typeof exitCode2 === "number") {
      if (exitCode2 !== 0) {
        Pervasives.failwith("should not request input!");
      } else {
        Pervasives.failwith("should not halt!");
      }
    } else {
      var match$4 = exitCode2[0] === 0;
      var rotate = match$4 ? /* Left */0 : /* Right */1;
      robot[0] = paintAndMove(robot[0], newColor, rotate);
    }
  }
};

var result = countPaintedPanels(robot[0]);

console.log("Part1 result: ", result);

var Part1 = /* module */[
  /* HPR */0,
  /* program */program,
  /* break */$$break,
  /* computer */computer,
  /* robot */robot,
  /* result */result
];

var program$1 = $$Array.map(Caml_format.caml_float_of_string, input.split(","));

var $$break$1 = /* record */[/* contents */false];

var computer$1 = /* record */[/* contents */IntCodeComputer$Adventofcode2019.make(undefined, program$1)];

var robot$1 = /* record */[/* contents */make(/* White */1)];

while(!$$break$1[0]) {
  var match$5 = detectColor(robot$1[0]);
  var color$1 = match$5 ? 1 : 0;
  var match$6 = IntCodeComputer$Adventofcode2019.run(computer$1[0], /* array */[color$1]);
  var exitCode1$1 = match$6[1];
  if (typeof exitCode1$1 === "number") {
    if (exitCode1$1 !== 0) {
      Pervasives.failwith("program should not request input here!");
    } else {
      $$break$1[0] = true;
    }
  } else {
    var match$7 = exitCode1$1[0] === 0;
    var newColor$1 = match$7 ? /* Black */0 : /* White */1;
    var match$8 = IntCodeComputer$Adventofcode2019.run(match$6[0], /* array */[]);
    var exitCode2$1 = match$8[1];
    computer$1[0] = match$8[0];
    if (typeof exitCode2$1 === "number") {
      if (exitCode2$1 !== 0) {
        Pervasives.failwith("should not request input!");
      } else {
        Pervasives.failwith("should not halt!");
      }
    } else {
      var match$9 = exitCode2$1[0] === 0;
      var rotate$1 = match$9 ? /* Left */0 : /* Right */1;
      robot$1[0] = paintAndMove(robot$1[0], newColor$1, rotate$1);
    }
  }
};

var result$1 = countPaintedPanels(robot$1[0]);

console.log("Part2 result:", result$1);

printHull(robot$1[0]);

var Part2 = /* module */[
  /* HPR */0,
  /* program */program$1,
  /* break */$$break$1,
  /* computer */computer$1,
  /* robot */robot$1,
  /* result */result$1
];

exports.inputPath = inputPath;
exports.input = input;
exports.HullPaintingRobot = HullPaintingRobot;
exports.Part1 = Part1;
exports.Part2 = Part2;
/* inputPath Not a pure module */
