// Generated by BUCKLESCRIPT VERSION 5.0.4, PLEASE EDIT WITH CARE
'use strict';

var Fs = require("fs");
var List = require("bs-platform/lib/js/list.js");
var Path = require("path");
var $$Array = require("bs-platform/lib/js/array.js");
var Caml_obj = require("bs-platform/lib/js/caml_obj.js");
var Js_option = require("bs-platform/lib/js/js_option.js");
var Belt_Array = require("bs-platform/lib/js/belt_Array.js");
var Caml_array = require("bs-platform/lib/js/caml_array.js");
var Caml_int32 = require("bs-platform/lib/js/caml_int32.js");
var Pervasives = require("bs-platform/lib/js/pervasives.js");
var Belt_SetInt = require("bs-platform/lib/js/belt_SetInt.js");
var Caml_format = require("bs-platform/lib/js/caml_format.js");
var Caml_option = require("bs-platform/lib/js/caml_option.js");

var inputPath = "./src/" + (Path.parse("Day07.re").name + ".input");

var input = Fs.readFileSync(inputPath, "utf8");

function toDigits(n) {
  var _acc = /* [] */0;
  var _n = n;
  while(true) {
    var n$1 = _n;
    var acc = _acc;
    var match = n$1 === 0;
    if (match) {
      return acc;
    } else {
      _n = n$1 / 10 | 0;
      _acc = /* :: */[
        n$1 % 10,
        acc
      ];
      continue ;
    }
  };
}

function padWithZeroes(_nums, size) {
  while(true) {
    var nums = _nums;
    var match = List.length(nums) === size;
    if (match) {
      return nums;
    } else {
      _nums = /* :: */[
        0,
        nums
      ];
      continue ;
    }
  };
}

function parseOpcode(instruction) {
  return instruction % 100;
}

function parseModes(instruction) {
  var digits = toDigits(instruction / 100 | 0);
  return $$Array.map((function (n) {
                if (n !== 0) {
                  if (n !== 1) {
                    return Pervasives.failwith("invalid input - unknown parameter mode");
                  } else {
                    return /* Immediate */1;
                  }
                } else {
                  return /* Position */0;
                }
              }), $$Array.of_list(padWithZeroes(digits, 3)).reverse());
}

function getByMode(program, address, mode) {
  var parameter = Caml_array.caml_array_get(program, address);
  if (mode) {
    return parameter;
  } else {
    return Caml_array.caml_array_get(program, parameter);
  }
}

function runProgram(program, inputs) {
  var inputs$1 = $$Array.copy(inputs);
  var _instructionPointer = 0;
  var program$1 = $$Array.copy(program);
  while(true) {
    var instructionPointer = _instructionPointer;
    var instruction = Caml_array.caml_array_get(program$1, instructionPointer);
    var opcode = instruction % 100;
    var modes = parseModes(instruction);
    if (opcode >= 9) {
      if (opcode !== 99) {
        return Pervasives.failwith("invalid opcode: " + String(opcode));
      } else {
        return /* tuple */[
                program$1,
                inputs$1
              ];
      }
    } else if (opcode > 0) {
      switch (opcode - 1 | 0) {
        case 0 : 
            var value1 = getByMode(program$1, instructionPointer + 1 | 0, Caml_array.caml_array_get(modes, 0));
            var value2 = getByMode(program$1, instructionPointer + 2 | 0, Caml_array.caml_array_get(modes, 1));
            var resultAddress = Caml_array.caml_array_get(program$1, instructionPointer + 3 | 0);
            Caml_array.caml_array_set(program$1, resultAddress, value1 + value2 | 0);
            _instructionPointer = instructionPointer + 4 | 0;
            continue ;
        case 1 : 
            var value1$1 = getByMode(program$1, instructionPointer + 1 | 0, Caml_array.caml_array_get(modes, 0));
            var value2$1 = getByMode(program$1, instructionPointer + 2 | 0, Caml_array.caml_array_get(modes, 1));
            var resultAddress$1 = Caml_array.caml_array_get(program$1, instructionPointer + 3 | 0);
            Caml_array.caml_array_set(program$1, resultAddress$1, Caml_int32.imul(value1$1, value2$1));
            _instructionPointer = instructionPointer + 4 | 0;
            continue ;
        case 2 : 
            var resultAddress$2 = Caml_array.caml_array_get(program$1, instructionPointer + 1 | 0);
            Caml_array.caml_array_set(program$1, resultAddress$2, Js_option.getExn(Caml_option.undefined_to_opt(inputs$1.shift())));
            _instructionPointer = instructionPointer + 2 | 0;
            continue ;
        case 3 : 
            var value = getByMode(program$1, instructionPointer + 1 | 0, Caml_array.caml_array_get(modes, 0));
            inputs$1.push(value);
            _instructionPointer = instructionPointer + 2 | 0;
            continue ;
        case 4 : 
            var value1$2 = getByMode(program$1, instructionPointer + 1 | 0, Caml_array.caml_array_get(modes, 0));
            var value2$2 = getByMode(program$1, instructionPointer + 2 | 0, Caml_array.caml_array_get(modes, 1));
            var match = value1$2 !== 0;
            var nextInstructionPointer = match ? value2$2 : instructionPointer + 3 | 0;
            _instructionPointer = nextInstructionPointer;
            continue ;
        case 5 : 
            var value1$3 = getByMode(program$1, instructionPointer + 1 | 0, Caml_array.caml_array_get(modes, 0));
            var value2$3 = getByMode(program$1, instructionPointer + 2 | 0, Caml_array.caml_array_get(modes, 1));
            var match$1 = value1$3 === 0;
            var nextInstructionPointer$1 = match$1 ? value2$3 : instructionPointer + 3 | 0;
            _instructionPointer = nextInstructionPointer$1;
            continue ;
        case 6 : 
            var value1$4 = getByMode(program$1, instructionPointer + 1 | 0, Caml_array.caml_array_get(modes, 0));
            var value2$4 = getByMode(program$1, instructionPointer + 2 | 0, Caml_array.caml_array_get(modes, 1));
            var resultAddress$3 = Caml_array.caml_array_get(program$1, instructionPointer + 3 | 0);
            var match$2 = value1$4 < value2$4;
            Caml_array.caml_array_set(program$1, resultAddress$3, match$2 ? 1 : 0);
            _instructionPointer = instructionPointer + 4 | 0;
            continue ;
        case 7 : 
            var value1$5 = getByMode(program$1, instructionPointer + 1 | 0, Caml_array.caml_array_get(modes, 0));
            var value2$5 = getByMode(program$1, instructionPointer + 2 | 0, Caml_array.caml_array_get(modes, 1));
            var resultAddress$4 = Caml_array.caml_array_get(program$1, instructionPointer + 3 | 0);
            var match$3 = value1$5 === value2$5;
            Caml_array.caml_array_set(program$1, resultAddress$4, match$3 ? 1 : 0);
            _instructionPointer = instructionPointer + 4 | 0;
            continue ;
        
      }
    } else {
      return Pervasives.failwith("invalid opcode: " + String(opcode));
    }
  };
}

function permutations(xs) {
  var results = /* array */[];
  var go = function (acc, xs) {
    if (Belt_SetInt.size(xs) === 0) {
      results.push($$Array.of_list(acc));
      return /* () */0;
    } else {
      return Belt_SetInt.forEach(xs, (function (x) {
                    return go(/* :: */[
                                x,
                                acc
                              ], Belt_SetInt.remove(xs, x));
                  }));
    }
  };
  go(/* [] */0, Belt_SetInt.fromArray(xs));
  return results;
}

var program = $$Array.map(Caml_format.caml_int_of_string, input.split(","));

var settingSequences = permutations(Belt_Array.range(0, 4));

function runSequence(seq) {
  var value = /* record */[/* contents */0];
  $$Array.iter((function (setting) {
          var match = runProgram(program, /* array */[
                setting,
                value[0]
              ]);
          value[0] = Caml_array.caml_array_get(match[1], 0);
          return /* () */0;
        }), seq);
  return value[0];
}

var result = $$Array.fold_left(Caml_obj.caml_max, Pervasives.min_int, $$Array.map(runSequence, settingSequences));

console.log("Part1 result: ", result);

var Part1 = /* module */[
  /* program */program,
  /* settingSequences */settingSequences,
  /* runSequence */runSequence,
  /* result */result
];

var initialProgram = $$Array.map(Caml_format.caml_int_of_string, input.split(","));

function runSequence$1(seq) {
  var value = /* record */[/* contents */0];
  var program = /* record */[/* contents */initialProgram];
  $$Array.iter((function (setting) {
          var match = runProgram(program[0], /* array */[
                setting,
                value[0]
              ]);
          value[0] = Caml_array.caml_array_get(match[1], 0);
          return /* () */0;
        }), seq);
  console.log("value: ", value);
  return value[0];
}

runSequence$1(/* array */[
      9,
      7,
      8,
      5,
      6
    ]);

console.log("Part2 result: ", "TBD");

var Part2 = /* module */[
  /* initialProgram */initialProgram,
  /* runSequence */runSequence$1
];

exports.inputPath = inputPath;
exports.input = input;
exports.toDigits = toDigits;
exports.padWithZeroes = padWithZeroes;
exports.parseOpcode = parseOpcode;
exports.parseModes = parseModes;
exports.getByMode = getByMode;
exports.runProgram = runProgram;
exports.permutations = permutations;
exports.Part1 = Part1;
exports.Part2 = Part2;
/* inputPath Not a pure module */
