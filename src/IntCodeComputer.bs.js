// Generated by BUCKLESCRIPT VERSION 5.0.4, PLEASE EDIT WITH CARE
'use strict';

var List = require("bs-platform/lib/js/list.js");
var $$Array = require("bs-platform/lib/js/array.js");
var Caml_array = require("bs-platform/lib/js/caml_array.js");
var Pervasives = require("bs-platform/lib/js/pervasives.js");

function make($staropt$star, program) {
  var memSize = $staropt$star !== undefined ? $staropt$star : 10000;
  var tape = Caml_array.caml_make_vect(memSize, 0);
  $$Array.blit(program, 0, tape, 0, program.length);
  return /* tuple */[
          tape,
          0,
          0
        ];
}

function getByMode(program, address, mode) {
  var parameter = Caml_array.caml_array_get(program, address);
  if (typeof mode === "number") {
    if (mode !== 0) {
      return parameter;
    } else {
      return Caml_array.caml_array_get(program, parameter | 0);
    }
  } else {
    return Caml_array.caml_array_get(program, mode[0] + (parameter | 0) | 0);
  }
}

function setByMode(program, address, mode, value) {
  var resultAddress = Caml_array.caml_array_get(program, address) | 0;
  if (typeof mode === "number") {
    if (mode !== 0) {
      return Pervasives.failwith("should not set in Immediate mode!");
    } else {
      return Caml_array.caml_array_set(program, resultAddress, value);
    }
  } else {
    return Caml_array.caml_array_set(program, mode[0] + resultAddress | 0, value);
  }
}

function parseInstruction(param) {
  var parseOpcode = function (instruction) {
    var opcode = instruction % 100;
    if (opcode >= 10) {
      if (opcode !== 99) {
        return Pervasives.failwith("unknown opcode: " + String(opcode));
      } else {
        return /* Halt */9;
      }
    } else if (opcode > 0) {
      return opcode - 1 | 0;
    } else {
      return Pervasives.failwith("unknown opcode: " + String(opcode));
    }
  };
  var parseModes = function (instruction, relativeBase) {
    var toDigits = function (n) {
      var _acc = /* [] */0;
      var _n = n;
      while(true) {
        var n$1 = _n;
        var acc = _acc;
        var match = n$1 === 0;
        if (match) {
          return acc;
        } else {
          _n = n$1 / 10 | 0;
          _acc = /* :: */[
            n$1 % 10,
            acc
          ];
          continue ;
        }
      };
    };
    var padWithZeroes = function (_nums, size) {
      while(true) {
        var nums = _nums;
        var match = List.length(nums) === size;
        if (match) {
          return nums;
        } else {
          _nums = /* :: */[
            0,
            nums
          ];
          continue ;
        }
      };
    };
    var digits = toDigits(instruction / 100 | 0);
    return $$Array.map((function (n) {
                  switch (n) {
                    case 0 : 
                        return /* Position */0;
                    case 1 : 
                        return /* Immediate */1;
                    case 2 : 
                        return /* Relative */[relativeBase];
                    default:
                      return Pervasives.failwith("invalid input - unknown parameter mode");
                  }
                }), $$Array.of_list(padWithZeroes(digits, 3)).reverse());
  };
  var instruction = Caml_array.caml_array_get(param[0], param[1]) | 0;
  var opcode = parseOpcode(instruction);
  var modes = parseModes(instruction, param[2]);
  return /* tuple */[
          opcode,
          modes
        ];
}

function run(computer, inputs) {
  var _computer = computer;
  var inputs$1 = $$Array.copy(inputs);
  while(true) {
    var computer$1 = _computer;
    var relativeBase = computer$1[2];
    var instructionPointer = computer$1[1];
    var tape = computer$1[0];
    var match = parseInstruction(computer$1);
    var modes = match[1];
    switch (match[0]) {
      case 0 : 
          var value1 = getByMode(tape, instructionPointer + 1 | 0, Caml_array.caml_array_get(modes, 0));
          var value2 = getByMode(tape, instructionPointer + 2 | 0, Caml_array.caml_array_get(modes, 1));
          setByMode(tape, instructionPointer + 3 | 0, Caml_array.caml_array_get(modes, 2), value1 + value2);
          _computer = /* tuple */[
            tape,
            instructionPointer + 4 | 0,
            relativeBase
          ];
          continue ;
      case 1 : 
          var value1$1 = getByMode(tape, instructionPointer + 1 | 0, Caml_array.caml_array_get(modes, 0));
          var value2$1 = getByMode(tape, instructionPointer + 2 | 0, Caml_array.caml_array_get(modes, 1));
          setByMode(tape, instructionPointer + 3 | 0, Caml_array.caml_array_get(modes, 2), value1$1 * value2$1);
          _computer = /* tuple */[
            tape,
            instructionPointer + 4 | 0,
            relativeBase
          ];
          continue ;
      case 2 : 
          var match$1 = inputs$1.shift();
          if (match$1 !== undefined) {
            setByMode(tape, instructionPointer + 1 | 0, Caml_array.caml_array_get(modes, 0), match$1);
            _computer = /* tuple */[
              tape,
              instructionPointer + 2 | 0,
              relativeBase
            ];
            continue ;
          } else {
            return /* tuple */[
                    computer$1,
                    /* Input */1
                  ];
          }
      case 3 : 
          var value = getByMode(tape, instructionPointer + 1 | 0, Caml_array.caml_array_get(modes, 0));
          return /* tuple */[
                  /* tuple */[
                    tape,
                    instructionPointer + 2 | 0,
                    relativeBase
                  ],
                  /* Output */[value]
                ];
      case 4 : 
          var value1$2 = getByMode(tape, instructionPointer + 1 | 0, Caml_array.caml_array_get(modes, 0));
          var value2$2 = getByMode(tape, instructionPointer + 2 | 0, Caml_array.caml_array_get(modes, 1));
          var match$2 = value1$2 !== 0;
          var nextInstructionPointer = match$2 ? value2$2 | 0 : instructionPointer + 3 | 0;
          _computer = /* tuple */[
            tape,
            nextInstructionPointer,
            relativeBase
          ];
          continue ;
      case 5 : 
          var value1$3 = getByMode(tape, instructionPointer + 1 | 0, Caml_array.caml_array_get(modes, 0));
          var value2$3 = getByMode(tape, instructionPointer + 2 | 0, Caml_array.caml_array_get(modes, 1));
          var match$3 = value1$3 === 0;
          var nextInstructionPointer$1 = match$3 ? value2$3 | 0 : instructionPointer + 3 | 0;
          _computer = /* tuple */[
            tape,
            nextInstructionPointer$1,
            relativeBase
          ];
          continue ;
      case 6 : 
          var value1$4 = getByMode(tape, instructionPointer + 1 | 0, Caml_array.caml_array_get(modes, 0));
          var value2$4 = getByMode(tape, instructionPointer + 2 | 0, Caml_array.caml_array_get(modes, 1));
          var match$4 = value1$4 < value2$4;
          setByMode(tape, instructionPointer + 3 | 0, Caml_array.caml_array_get(modes, 2), match$4 ? 1 : 0);
          _computer = /* tuple */[
            tape,
            instructionPointer + 4 | 0,
            relativeBase
          ];
          continue ;
      case 7 : 
          var value1$5 = getByMode(tape, instructionPointer + 1 | 0, Caml_array.caml_array_get(modes, 0));
          var value2$5 = getByMode(tape, instructionPointer + 2 | 0, Caml_array.caml_array_get(modes, 1));
          var match$5 = value1$5 === value2$5;
          setByMode(tape, instructionPointer + 3 | 0, Caml_array.caml_array_get(modes, 2), match$5 ? 1 : 0);
          _computer = /* tuple */[
            tape,
            instructionPointer + 4 | 0,
            relativeBase
          ];
          continue ;
      case 8 : 
          var value$1 = getByMode(tape, instructionPointer + 1 | 0, Caml_array.caml_array_get(modes, 0));
          var newRelativeBase = relativeBase + (value$1 | 0) | 0;
          _computer = /* tuple */[
            tape,
            instructionPointer + 2 | 0,
            newRelativeBase
          ];
          continue ;
      case 9 : 
          return /* tuple */[
                  computer$1,
                  /* Halt */0
                ];
      
    }
  };
}

exports.make = make;
exports.run = run;
/* No side effect */
