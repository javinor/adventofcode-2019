// Generated by BUCKLESCRIPT VERSION 5.0.4, PLEASE EDIT WITH CARE
'use strict';

var Fs = require("fs");
var List = require("bs-platform/lib/js/list.js");
var Path = require("path");
var $$Array = require("bs-platform/lib/js/array.js");
var Belt_Id = require("bs-platform/lib/js/belt_Id.js");
var Belt_Map = require("bs-platform/lib/js/belt_Map.js");
var Caml_obj = require("bs-platform/lib/js/caml_obj.js");
var Js_option = require("bs-platform/lib/js/js_option.js");
var Caml_array = require("bs-platform/lib/js/caml_array.js");
var Pervasives = require("bs-platform/lib/js/pervasives.js");
var Caml_format = require("bs-platform/lib/js/caml_format.js");
var Caml_primitive = require("bs-platform/lib/js/caml_primitive.js");
var IntCodeComputer$Adventofcode2019 = require("./IntCodeComputer.bs.js");

var inputPath = "./src/" + (Path.parse("Day13.re").name + ".input");

var input = Fs.readFileSync(inputPath, "utf8");

function parseTileId(n) {
  if (n > 4 || n < 0) {
    return Pervasives.failwith("invalid tileId: " + String(n));
  } else {
    return n;
  }
}

var cmp = Caml_obj.caml_compare;

var Coords = Belt_Id.MakeComparable(/* module */[/* cmp */cmp]);

function screen_of_outputs(xs) {
  var _screen = /* record */[
    /* score */0,
    /* grid */Belt_Map.make(Coords)
  ];
  var _xs = xs;
  while(true) {
    var xs$1 = _xs;
    var screen = _screen;
    if (xs$1) {
      var match = xs$1[1];
      if (match) {
        var match$1 = match[1];
        if (match$1) {
          var rest = match$1[1];
          var x = xs$1[0] | 0;
          var y = match[0] | 0;
          var tileId = match$1[0] | 0;
          if (x === -1 && y === 0) {
            _xs = rest;
            _screen = /* record */[
              /* score */tileId,
              /* grid */screen[/* grid */1]
            ];
            continue ;
          } else {
            var tile = parseTileId(tileId);
            var grid = Belt_Map.set(screen[/* grid */1], /* tuple */[
                  x,
                  y
                ], tile);
            _xs = rest;
            _screen = /* record */[
              /* score */screen[/* score */0],
              /* grid */grid
            ];
            continue ;
          }
        } else {
          return Pervasives.failwith("outputs length should be divisible by 3");
        }
      } else {
        return Pervasives.failwith("outputs length should be divisible by 3");
      }
    } else {
      return screen;
    }
  };
}

function consumeOutputs(computer, inputs) {
  var go = function (_computer, _outputs) {
    while(true) {
      var outputs = _outputs;
      var computer = _computer;
      var match = IntCodeComputer$Adventofcode2019.run(computer, inputs);
      var exitCode = match[1];
      var computer$1 = match[0];
      if (typeof exitCode === "number") {
        return /* tuple */[
                computer$1,
                exitCode,
                List.rev(outputs)
              ];
      } else {
        _outputs = /* :: */[
          exitCode[0],
          outputs
        ];
        _computer = computer$1;
        continue ;
      }
    };
  };
  var match = go(computer, /* [] */0);
  var screen = screen_of_outputs(match[2]);
  return /* tuple */[
          match[0],
          match[1],
          screen
        ];
}

function printGrid(grid) {
  var coords = Belt_Map.keysToArray(grid);
  var match = $$Array.fold_left((function (param, param$1) {
          return /* tuple */[
                  Caml_primitive.caml_int_max(param[0], param$1[0]),
                  Caml_primitive.caml_int_max(param[1], param$1[1])
                ];
        }), /* tuple */[
        Pervasives.min_int,
        Pervasives.min_int
      ], coords);
  var grid$prime = $$Array.make_matrix(match[1] + 1 | 0, match[0] + 1 | 0, "");
  Belt_Map.forEach(grid, (function (param, tile) {
          var str;
          switch (tile) {
            case 0 : 
                str = " ";
                break;
            case 1 : 
                str = "W";
                break;
            case 2 : 
                str = "b";
                break;
            case 3 : 
                str = "=";
                break;
            case 4 : 
                str = "*";
                break;
            
          }
          return Caml_array.caml_array_set(Caml_array.caml_array_get(grid$prime, param[1]), param[0], str);
        }));
  return $$Array.iter((function (row) {
                console.log(row.join(""));
                return /* () */0;
              }), grid$prime);
}

var program = $$Array.map(Caml_format.caml_float_of_string, input.split(","));

var match = consumeOutputs(IntCodeComputer$Adventofcode2019.make(undefined, program), /* array */[]);

var screen = match[2];

var result = $$Array.fold_left((function (nBlocks, tile) {
        if (tile !== 2) {
          return nBlocks;
        } else {
          return nBlocks + 1 | 0;
        }
      }), 0, Belt_Map.valuesToArray(screen[/* grid */1]));

console.log("Part1 result: ", result);

var Part1 = /* module */[
  /* program */program,
  /* screen */screen,
  /* result */result
];

function float_of_joystick(j) {
  switch (j) {
    case 0 : 
        return 0;
    case 1 : 
        return -1;
    case 2 : 
        return 1;
    
  }
}

function play(computer) {
  var _computer = computer;
  var _inputs = /* array */[];
  var _screen = /* record */[
    /* score */0,
    /* grid */Belt_Map.make(Coords)
  ];
  while(true) {
    var screen = _screen;
    var inputs = _inputs;
    var computer$1 = _computer;
    var match = consumeOutputs(computer$1, inputs);
    var screen$prime = match[2];
    var exitCode = match[1];
    console.log("screen'.grid: ", Belt_Map.toArray(screen$prime[/* grid */1]));
    var nextScreen_000 = /* score */screen$prime[/* score */0];
    var nextScreen_001 = /* grid */Belt_Map.merge(screen[/* grid */1], screen$prime[/* grid */1], (function (param, v1, v2) {
            var match = Js_option.isNone(v2);
            if (match) {
              return v1;
            } else {
              return v2;
            }
          }));
    var nextScreen = /* record */[
      nextScreen_000,
      nextScreen_001
    ];
    printGrid(nextScreen_001);
    if (typeof exitCode === "number") {
      if (exitCode !== 0) {
        var match$1 = Js_option.getExn(Belt_Map.findFirstBy(nextScreen_001, (function (param, tile) {
                    return tile === /* Ball */4;
                  })));
        var match$2 = match$1[0];
        var ballX = match$2[0];
        var match$3 = Js_option.getExn(Belt_Map.findFirstBy(nextScreen_001, (function (param, tile) {
                    return tile === /* Paddle */3;
                  })));
        var match$4 = match$3[0];
        var paddleX = match$4[0];
        var match$5 = ballX < paddleX;
        var joystick;
        if (match$5) {
          joystick = /* Left */1;
        } else {
          var match$6 = ballX > paddleX;
          joystick = match$6 ? /* Right */2 : /* Neutral */0;
        }
        console.log("ball: ", /* tuple */[
              ballX,
              match$2[1]
            ]);
        console.log("paddle: ", /* tuple */[
              paddleX,
              match$4[1]
            ]);
        _screen = nextScreen;
        _inputs = /* array */[float_of_joystick(joystick)];
        _computer = match[0];
        continue ;
      } else {
        return nextScreen;
      }
    } else {
      return Pervasives.failwith("all output should have been consumed!");
    }
  };
}

var program$1 = $$Array.map(Caml_format.caml_float_of_string, input.split(","));

Caml_array.caml_array_set(program$1, 0, 2);

var screen$1 = play(IntCodeComputer$Adventofcode2019.make(undefined, program$1));

var result$1 = screen$1[/* score */0];

console.log("Part2 result: ", result$1);

var Part2 = /* module */[
  /* float_of_joystick */float_of_joystick,
  /* play */play,
  /* program */program$1,
  /* screen */screen$1,
  /* result */result$1
];

exports.inputPath = inputPath;
exports.input = input;
exports.parseTileId = parseTileId;
exports.Coords = Coords;
exports.screen_of_outputs = screen_of_outputs;
exports.consumeOutputs = consumeOutputs;
exports.printGrid = printGrid;
exports.Part1 = Part1;
exports.Part2 = Part2;
/* inputPath Not a pure module */
