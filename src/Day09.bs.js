// Generated by BUCKLESCRIPT VERSION 5.0.4, PLEASE EDIT WITH CARE
'use strict';

var Fs = require("fs");
var List = require("bs-platform/lib/js/list.js");
var Path = require("path");
var $$Array = require("bs-platform/lib/js/array.js");
var Caml_array = require("bs-platform/lib/js/caml_array.js");
var Pervasives = require("bs-platform/lib/js/pervasives.js");
var Caml_format = require("bs-platform/lib/js/caml_format.js");

var inputPath = "./src/" + (Path.parse("Day09.re").name + ".input");

var input = Fs.readFileSync(inputPath, "utf8");

function toDigits(n) {
  var _acc = /* [] */0;
  var _n = n;
  while(true) {
    var n$1 = _n;
    var acc = _acc;
    var match = n$1 === 0;
    if (match) {
      return acc;
    } else {
      _n = n$1 / 10 | 0;
      _acc = /* :: */[
        n$1 % 10,
        acc
      ];
      continue ;
    }
  };
}

function padWithZeroes(_nums, size) {
  while(true) {
    var nums = _nums;
    var match = List.length(nums) === size;
    if (match) {
      return nums;
    } else {
      _nums = /* :: */[
        0,
        nums
      ];
      continue ;
    }
  };
}

function parseOpcode(instruction) {
  return instruction % 100;
}

function parseModes(instruction, relativeBase) {
  var digits = toDigits(instruction / 100 | 0);
  return $$Array.map((function (n) {
                switch (n) {
                  case 0 : 
                      return /* Position */0;
                  case 1 : 
                      return /* Immediate */1;
                  case 2 : 
                      return /* Relative */[relativeBase];
                  default:
                    return Pervasives.failwith("invalid input - unknown parameter mode");
                }
              }), $$Array.of_list(padWithZeroes(digits, 3)).reverse());
}

function getByMode(program, address, mode) {
  var parameter = Caml_array.caml_array_get(program, address);
  if (typeof mode === "number") {
    if (mode !== 0) {
      return parameter;
    } else {
      return Caml_array.caml_array_get(program, parameter | 0);
    }
  } else {
    return Caml_array.caml_array_get(program, mode[0] + (parameter | 0) | 0);
  }
}

function setByMode(program, address, mode, value) {
  var resultAddress = Caml_array.caml_array_get(program, address) | 0;
  if (typeof mode === "number") {
    if (mode !== 0) {
      return Pervasives.failwith("should not set in Immediate mode!");
    } else {
      return Caml_array.caml_array_set(program, resultAddress, value);
    }
  } else {
    return Caml_array.caml_array_set(program, mode[0] + resultAddress | 0, value);
  }
}

function runProgram(program, instructionPointer, relativeBase, inputs) {
  var inputs$1 = $$Array.copy(inputs);
  var relativeBase$1 = /* record */[/* contents */relativeBase];
  var program$prime = Caml_array.caml_make_vect(10000, 0);
  $$Array.blit(program, 0, program$prime, 0, program.length);
  var _instructionPointer = instructionPointer;
  var program$1 = program$prime;
  while(true) {
    var instructionPointer$1 = _instructionPointer;
    var instruction = Caml_array.caml_array_get(program$1, instructionPointer$1) | 0;
    var opcode = instruction % 100;
    var modes = parseModes(instruction, relativeBase$1[0]);
    if (opcode >= 10) {
      if (opcode !== 99) {
        return Pervasives.failwith("invalid opcode: " + String(opcode));
      } else {
        return /* tuple */[
                program$1,
                instructionPointer$1,
                relativeBase$1[0],
                /* Halt */0
              ];
      }
    } else if (opcode > 0) {
      switch (opcode - 1 | 0) {
        case 0 : 
            var value1 = getByMode(program$1, instructionPointer$1 + 1 | 0, Caml_array.caml_array_get(modes, 0));
            var value2 = getByMode(program$1, instructionPointer$1 + 2 | 0, Caml_array.caml_array_get(modes, 1));
            setByMode(program$1, instructionPointer$1 + 3 | 0, Caml_array.caml_array_get(modes, 2), value1 + value2);
            _instructionPointer = instructionPointer$1 + 4 | 0;
            continue ;
        case 1 : 
            var value1$1 = getByMode(program$1, instructionPointer$1 + 1 | 0, Caml_array.caml_array_get(modes, 0));
            var value2$1 = getByMode(program$1, instructionPointer$1 + 2 | 0, Caml_array.caml_array_get(modes, 1));
            setByMode(program$1, instructionPointer$1 + 3 | 0, Caml_array.caml_array_get(modes, 2), value1$1 * value2$1);
            _instructionPointer = instructionPointer$1 + 4 | 0;
            continue ;
        case 2 : 
            var match = inputs$1.shift();
            if (match !== undefined) {
              setByMode(program$1, instructionPointer$1 + 1 | 0, Caml_array.caml_array_get(modes, 0), match);
              _instructionPointer = instructionPointer$1 + 2 | 0;
              continue ;
            } else {
              return /* tuple */[
                      program$1,
                      instructionPointer$1,
                      relativeBase$1[0],
                      /* Input */1
                    ];
            }
        case 3 : 
            var value = getByMode(program$1, instructionPointer$1 + 1 | 0, Caml_array.caml_array_get(modes, 0));
            return /* tuple */[
                    program$1,
                    instructionPointer$1 + 2 | 0,
                    relativeBase$1[0],
                    /* Output */[value]
                  ];
        case 4 : 
            var value1$2 = getByMode(program$1, instructionPointer$1 + 1 | 0, Caml_array.caml_array_get(modes, 0));
            var value2$2 = getByMode(program$1, instructionPointer$1 + 2 | 0, Caml_array.caml_array_get(modes, 1));
            var match$1 = value1$2 !== 0;
            var nextInstructionPointer = match$1 ? value2$2 | 0 : instructionPointer$1 + 3 | 0;
            _instructionPointer = nextInstructionPointer;
            continue ;
        case 5 : 
            var value1$3 = getByMode(program$1, instructionPointer$1 + 1 | 0, Caml_array.caml_array_get(modes, 0));
            var value2$3 = getByMode(program$1, instructionPointer$1 + 2 | 0, Caml_array.caml_array_get(modes, 1));
            var match$2 = value1$3 === 0;
            var nextInstructionPointer$1 = match$2 ? value2$3 | 0 : instructionPointer$1 + 3 | 0;
            _instructionPointer = nextInstructionPointer$1;
            continue ;
        case 6 : 
            var value1$4 = getByMode(program$1, instructionPointer$1 + 1 | 0, Caml_array.caml_array_get(modes, 0));
            var value2$4 = getByMode(program$1, instructionPointer$1 + 2 | 0, Caml_array.caml_array_get(modes, 1));
            var match$3 = value1$4 < value2$4;
            setByMode(program$1, instructionPointer$1 + 3 | 0, Caml_array.caml_array_get(modes, 2), match$3 ? 1 : 0);
            _instructionPointer = instructionPointer$1 + 4 | 0;
            continue ;
        case 7 : 
            var value1$5 = getByMode(program$1, instructionPointer$1 + 1 | 0, Caml_array.caml_array_get(modes, 0));
            var value2$5 = getByMode(program$1, instructionPointer$1 + 2 | 0, Caml_array.caml_array_get(modes, 1));
            var match$4 = value1$5 === value2$5;
            setByMode(program$1, instructionPointer$1 + 3 | 0, Caml_array.caml_array_get(modes, 2), match$4 ? 1 : 0);
            _instructionPointer = instructionPointer$1 + 4 | 0;
            continue ;
        case 8 : 
            var value$1 = getByMode(program$1, instructionPointer$1 + 1 | 0, Caml_array.caml_array_get(modes, 0));
            relativeBase$1[0] = relativeBase$1[0] + (value$1 | 0) | 0;
            _instructionPointer = instructionPointer$1 + 2 | 0;
            continue ;
        
      }
    } else {
      return Pervasives.failwith("invalid opcode: " + String(opcode));
    }
  };
}

var program = $$Array.map(Caml_format.caml_float_of_string, input.split(","));

var $$break = /* record */[/* contents */false];

var computer = /* record */[/* contents : tuple */[
    program,
    0,
    0
  ]];

while(!$$break[0]) {
  var match = computer[0];
  var match$1 = runProgram(match[0], match[1], match[2], /* array */[1]);
  var output = match$1[3];
  computer[0] = /* tuple */[
    match$1[0],
    match$1[1],
    match$1[2]
  ];
  if (typeof output === "number") {
    if (output !== 0) {
      Pervasives.failwith("program should finish with output");
    } else {
      $$break[0] = true;
    }
  } else {
    console.log("Part1 output: ", output[0], "\n");
  }
};

var Part1 = /* module */[
  /* program */program,
  /* break */$$break,
  /* computer */computer
];

var program$1 = $$Array.map(Caml_format.caml_float_of_string, input.split(","));

var $$break$1 = /* record */[/* contents */false];

var computer$1 = /* record */[/* contents : tuple */[
    program$1,
    0,
    0
  ]];

while(!$$break$1[0]) {
  var match$2 = computer$1[0];
  var match$3 = runProgram(match$2[0], match$2[1], match$2[2], /* array */[2]);
  var output$1 = match$3[3];
  computer$1[0] = /* tuple */[
    match$3[0],
    match$3[1],
    match$3[2]
  ];
  if (typeof output$1 === "number") {
    if (output$1 !== 0) {
      Pervasives.failwith("program should finish with output");
    } else {
      $$break$1[0] = true;
    }
  } else {
    console.log("Part2 output: ", output$1[0], "\n");
  }
};

var Part2 = /* module */[
  /* program */program$1,
  /* break */$$break$1,
  /* computer */computer$1
];

exports.inputPath = inputPath;
exports.input = input;
exports.toDigits = toDigits;
exports.padWithZeroes = padWithZeroes;
exports.parseOpcode = parseOpcode;
exports.parseModes = parseModes;
exports.getByMode = getByMode;
exports.setByMode = setByMode;
exports.runProgram = runProgram;
exports.Part1 = Part1;
exports.Part2 = Part2;
/* inputPath Not a pure module */
