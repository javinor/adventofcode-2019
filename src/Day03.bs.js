// Generated by BUCKLESCRIPT VERSION 5.0.4, PLEASE EDIT WITH CARE
'use strict';

var Fs = require("fs");
var Path = require("path");
var $$Array = require("bs-platform/lib/js/array.js");
var Belt_Id = require("bs-platform/lib/js/belt_Id.js");
var Belt_Map = require("bs-platform/lib/js/belt_Map.js");
var Belt_Set = require("bs-platform/lib/js/belt_Set.js");
var Caml_obj = require("bs-platform/lib/js/caml_obj.js");
var Caml_array = require("bs-platform/lib/js/caml_array.js");
var Pervasives = require("bs-platform/lib/js/pervasives.js");
var Caml_format = require("bs-platform/lib/js/caml_format.js");
var Caml_string = require("bs-platform/lib/js/caml_string.js");

var inputPath = "./src/" + (Path.parse("Day03.re").name + ".input");

var dummy_input = /* array */[
  "R8,U5,L5,D3",
  "U7,R6,D4,L4"
];

var cmp = Caml_obj.caml_compare;

var Points = Belt_Id.MakeComparable(/* module */[/* cmp */cmp]);

function parseWire(str) {
  return $$Array.map((function (segment) {
                var match = Caml_string.get(segment, 0);
                var direction;
                switch (match) {
                  case 68 : 
                      direction = /* Down */2;
                      break;
                  case 76 : 
                      direction = /* Left */3;
                      break;
                  case 82 : 
                      direction = /* Right */1;
                      break;
                  case 69 : 
                  case 70 : 
                  case 71 : 
                  case 72 : 
                  case 73 : 
                  case 74 : 
                  case 75 : 
                  case 77 : 
                  case 78 : 
                  case 79 : 
                  case 80 : 
                  case 81 : 
                  case 83 : 
                  case 84 : 
                      direction = Pervasives.failwith("bad input - unknown direction");
                      break;
                  case 85 : 
                      direction = /* Up */0;
                      break;
                  default:
                    direction = Pervasives.failwith("bad input - unknown direction");
                }
                var magnitude = Caml_format.caml_int_of_string(segment.slice(1));
                return /* tuple */[
                        direction,
                        magnitude
                      ];
              }), str.split(","));
}

function dist(param, param$1) {
  return Pervasives.abs(param[0] - param$1[0] | 0) + Pervasives.abs(param[1] - param$1[1] | 0) | 0;
}

function wireToPoints(wire) {
  var empty = Belt_Set.make(Points);
  var _acc = empty;
  var _wire = $$Array.to_list(wire);
  var _param = /* tuple */[
    0,
    0
  ];
  while(true) {
    var param = _param;
    var wire$1 = _wire;
    var acc = _acc;
    if (wire$1) {
      var match = wire$1[0];
      var n = match[1];
      var direction = match[0];
      var y = param[1];
      var x = param[0];
      if (n !== 0) {
        var p;
        switch (direction) {
          case 0 : 
              p = /* tuple */[
                x,
                y + 1 | 0
              ];
              break;
          case 1 : 
              p = /* tuple */[
                x + 1 | 0,
                y
              ];
              break;
          case 2 : 
              p = /* tuple */[
                x,
                y - 1 | 0
              ];
              break;
          case 3 : 
              p = /* tuple */[
                x - 1 | 0,
                y
              ];
              break;
          
        }
        _param = p;
        _wire = /* :: */[
          /* tuple */[
            direction,
            n - 1 | 0
          ],
          wire$1[1]
        ];
        _acc = Belt_Set.add(acc, p);
        continue ;
      } else {
        _param = /* tuple */[
          x,
          y
        ];
        _wire = wire$1[1];
        continue ;
      }
    } else {
      return acc;
    }
  };
}

var points = $$Array.map(wireToPoints, $$Array.map(parseWire, Fs.readFileSync(inputPath, "utf8").split("\n")));

var intersection = Belt_Set.intersect(Caml_array.caml_array_get(points, 0), Caml_array.caml_array_get(points, 1));

var result = $$Array.map((function (p) {
        return /* tuple */[
                p,
                dist(p, /* tuple */[
                      0,
                      0
                    ])
              ];
      }), Belt_Set.toArray(intersection));

console.log("Part1 result: ", result);

var Part1 = /* module */[
  /* wireToPoints */wireToPoints,
  /* points */points,
  /* intersection */intersection,
  /* result */result
];

function wireToPath(wire) {
  var empty = Belt_Map.make(Points);
  var _acc = empty;
  var _wire = $$Array.to_list(wire);
  var _param = /* tuple */[
    0,
    0
  ];
  var _steps = 0;
  while(true) {
    var param = _param;
    var steps = _steps;
    var wire$1 = _wire;
    var acc = _acc;
    if (wire$1) {
      var match = wire$1[0];
      var n = match[1];
      var direction = match[0];
      var y = param[1];
      var x = param[0];
      if (n !== 0) {
        var nextP;
        switch (direction) {
          case 0 : 
              nextP = /* tuple */[
                x,
                y + 1 | 0
              ];
              break;
          case 1 : 
              nextP = /* tuple */[
                x + 1 | 0,
                y
              ];
              break;
          case 2 : 
              nextP = /* tuple */[
                x,
                y - 1 | 0
              ];
              break;
          case 3 : 
              nextP = /* tuple */[
                x - 1 | 0,
                y
              ];
              break;
          
        }
        var nextAcc = Belt_Map.update(acc, nextP, (function(steps){
            return function (prev) {
              if (prev !== undefined) {
                return prev;
              } else {
                return steps + 1 | 0;
              }
            }
            }(steps)));
        _steps = steps + 1 | 0;
        _param = nextP;
        _wire = /* :: */[
          /* tuple */[
            direction,
            n - 1 | 0
          ],
          wire$1[1]
        ];
        _acc = nextAcc;
        continue ;
      } else {
        _param = /* tuple */[
          x,
          y
        ];
        _wire = wire$1[1];
        continue ;
      }
    } else {
      return acc;
    }
  };
}

var input = Fs.readFileSync(inputPath, "utf8").split("\n");

var paths = $$Array.map(wireToPath, $$Array.map(parseWire, input));

var intersection$1 = Belt_Map.merge(Caml_array.caml_array_get(paths, 0), Caml_array.caml_array_get(paths, 1), (function (param, steps, steps$prime) {
        if (steps !== undefined && steps$prime !== undefined) {
          return steps + steps$prime | 0;
        }
        
      }));

console.log("Part2 result: ", Belt_Map.toArray(intersection$1));

var Part2 = /* module */[
  /* wireToPath */wireToPath,
  /* input */input,
  /* paths */paths,
  /* intersection */intersection$1
];

exports.inputPath = inputPath;
exports.dummy_input = dummy_input;
exports.Points = Points;
exports.parseWire = parseWire;
exports.dist = dist;
exports.Part1 = Part1;
exports.Part2 = Part2;
/* inputPath Not a pure module */
